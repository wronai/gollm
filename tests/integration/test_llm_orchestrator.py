import asyncio
from unittest.mock import AsyncMock, Mock

import pytest

from gollm.config.config import GollmConfig
from gollm.llm.orchestrator import LLMOrchestrator, LLMRequest, LLMResponse


class TestLLMOrchestrator:

    @pytest.fixture
    def config(self):
        """Test configuration"""
        return GollmConfig.default()

    @pytest.fixture
    def orchestrator(self, config):
        """Test LLMOrchestrator instance with mocked dependencies"""
        orchestrator = LLMOrchestrator(config)

        # Mock dependencies
        orchestrator.context_builder = Mock()
        orchestrator.context_builder.build_context = AsyncMock(
            return_value={
                "execution_context": {},
                "todo_context": {},
                "project_config": {},
            }
        )

        orchestrator.prompt_formatter = Mock()
        orchestrator.prompt_formatter.create_prompt = Mock(return_value="Test prompt")

        orchestrator.response_validator = Mock()
        # Create a mock code validator with a numeric quality score
        mock_code_validator = Mock()
        mock_code_validator.validate_content.return_value = {
            "violations": [],
            "quality_score": 95,  # Ensure this is a number, not a Mock
        }

        # Create a mock response validator
        mock_response_validator = Mock()
        mock_response_validator.validate_response = AsyncMock(
            return_value={
                "code_extracted": True,
                "extracted_code": "def test(): pass",
                "explanation": "Test function generated by mock",
                "syntax_valid": True,
                "code_quality": {
                    "quality_score": 90,  # Numeric quality score
                    "violations": [],
                },
                "validation_passed": True,
                "success": True,
            }
        )

        # Apply the mocks to the orchestrator
        orchestrator.code_validator = mock_code_validator
        orchestrator.response_validator = mock_response_validator

        return orchestrator

    def test_llm_request_creation(self):
        """Test LLMRequest dataclass"""
        request = LLMRequest(
            user_request="Create a function",
            context={"test": "context"},
            session_id="test-session",
            max_iterations=3,
        )

        assert request.user_request == "Create a function"
        assert request.context == {"test": "context"}
        assert request.session_id == "test-session"
        assert request.max_iterations == 3

    def test_llm_response_creation(self):
        """Test LLMResponse dataclass"""
        response = LLMResponse(
            generated_code="def test(): pass",
            explanation="Test function",
            validation_result={"violations": []},
            iterations_used=1,
            quality_score=95,
        )

        assert response.generated_code == "def test(): pass"
        assert response.explanation == "Test function"
        assert response.iterations_used == 1
        assert response.quality_score == 95

    @pytest.mark.asyncio
    async def test_handle_code_generation_request(self, orchestrator):
        """Test code generation request handling"""
        # Mock the LLM call to return a well-formed response
        mock_llm_response = '''
Here's a test function:

```python
def test_function():
    """Test function"""
    return "test"
```

**Explanation:**
This is a test function that returns the string "test".
'''

        # Mock the _simulate_llm_call method
        orchestrator._simulate_llm_call = AsyncMock(return_value=mock_llm_response)

        # Mock the response validator to return a proper validation result
        orchestrator.response_validator.validate_response = AsyncMock(
            return_value={
                "code_extracted": True,
                "extracted_code": 'def test_function():\n    """Test function"""\n    return "test"',
                "explanation": "This is a test function that returns the string 'test'.",
                "syntax_valid": True,
                "code_quality": {
                    "quality_score": 95,  # Numeric score
                    "violations": [],
                },
                "validation_passed": True,
                "success": True,
            }
        )

        # Mock the code validator to return a proper validation result
        orchestrator.code_validator.validate_content = Mock(
            return_value={"violations": [], "quality_score": 95, "success": True}
        )

        # Execute the request
        response = await orchestrator.handle_code_generation_request(
            "Create a test function"
        )

        # Verify the response
        assert isinstance(response, LLMResponse)
        assert "def test_function" in response.generated_code
        assert response.quality_score > 0
        assert response.iterations_used > 0
        assert response.validation_result["validation_passed"] is True
